<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>unity api on 泽梅尔的驻留地</title><link>https://www.zling.site/tags/unity-api/</link><description>Recent content in unity api on 泽梅尔的驻留地</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 26 Apr 2021 22:27:49 +0800</lastBuildDate><atom:link href="https://www.zling.site/tags/unity-api/index.xml" rel="self" type="application/rss+xml"/><item><title>Unity中的RuntimeRuntimeInitializeOnLoadMethodAttribute</title><link>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84RuntimeRuntimeInitializeOnLoadMethodAttribute/</link><pubDate>Mon, 26 Apr 2021 22:27:49 +0800</pubDate><guid>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84RuntimeRuntimeInitializeOnLoadMethodAttribute/</guid><description>被此特性标注的方法将在 Awake 方法之后被 Unity 循环调用，而且被此特性标记的所有方法，它们之间的执行顺序不是固定的。 示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 using UnityEngine; public class MyTest : MonoBehaviour { [RuntimeInitializeOnLoadMethod] static void OnRuntimeMethodLoad() { Debug.Log(&amp;#34;After Scene is loaded and game is running&amp;#34;); } [RuntimeInitializeOnLoadMethod] static void OnSecondRuntimeMethodLoad() { Debug.Log(&amp;#34;SecondMethod After Scene is loaded and game is running.&amp;#34;); } private void Awake() { Debug.Log(&amp;#34;Awake method&amp;#34;); } private void Start() { Debug.Log(&amp;#34;Start method&amp;#34;); } } 结果：</description></item></channel></rss>