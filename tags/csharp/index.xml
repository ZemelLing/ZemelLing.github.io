<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>csharp on 泽梅尔的驻留地</title><link>https://www.zling.site/tags/csharp/</link><description>Recent content in csharp on 泽梅尔的驻留地</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 25 Oct 2021 09:54:30 +0800</lastBuildDate><atom:link href="https://www.zling.site/tags/csharp/index.xml" rel="self" type="application/rss+xml"/><item><title>CSharp查缺补漏之重写(override)和覆盖(new)的区别</title><link>https://www.zling.site/post/CSharp%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F%E4%B9%8B%E9%87%8D%E5%86%99%E5%92%8C%E8%A6%86%E7%9B%96%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 25 Oct 2021 09:54:30 +0800</pubDate><guid>https://www.zling.site/post/CSharp%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F%E4%B9%8B%E9%87%8D%E5%86%99%E5%92%8C%E8%A6%86%E7%9B%96%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>不管是重写还是覆盖都不会影响父类自身的功能（废话，肯定的嘛，除非代码被改）。 当用子类创建父类的时候，如 C1 c3 = new C2()，重写会改变父类的功能，即调用子类的功能；而覆盖不会，仍然调用父类功能。 虚方法、实方法都可以被覆盖（new），抽象方法，接口 不可以。 抽象方法，接口，标记为virt</description></item><item><title>CSharp查缺补漏20210928</title><link>https://www.zling.site/post/CSharp%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F20210928/</link><pubDate>Tue, 28 Sep 2021 15:52:28 +0800</pubDate><guid>https://www.zling.site/post/CSharp%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F20210928/</guid><description>c# 7.0 特性 数字字面量的改进 数字字面量可以使用下划线来改善可读性、它们称为数字分隔符而被编译器忽略 1 2 3 int million = 1_000_000; var b = 0b1010_1011_1100_1101_1110_1111; // 二进制字面量可以使用0b前缀进行标识 解构器 解构方法的名字必须为Deconstruct，并且拥有一个或多个out参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Rectangle { public readonly float Width, Height; public</description></item><item><title>使用Activator动态创建实例</title><link>https://www.zling.site/post/%E4%BD%BF%E7%94%A8Activator%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B/</link><pubDate>Mon, 27 Sep 2021 11:07:17 +0800</pubDate><guid>https://www.zling.site/post/%E4%BD%BF%E7%94%A8Activator%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B/</guid><description>Activator Activator 包含能够创建本地或远程类型对象或获取对现有远程对象的引用的方法。 重要的方法 CreateInstance 此方法通过调用与给定参数最匹配的类构造函数创建类的实例。默认情况下，如果被创建实例的类没有Public的构造函数或找不到匹配的构造函数，此方法将抛出异常。</description></item><item><title>日志依赖注入报错的问题</title><link>https://www.zling.site/post/%E6%97%A5%E5%BF%97%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%8A%A5%E9%94%99%E7%9A%84%E9%97%AE%E9%A2%98/</link><pubDate>Sun, 08 Aug 2021 11:57:40 +0800</pubDate><guid>https://www.zling.site/post/%E6%97%A5%E5%BF%97%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%8A%A5%E9%94%99%E7%9A%84%E9%97%AE%E9%A2%98/</guid><description>依赖注入时报如下错误的解决办法 1 System.InvalidOperationException: Unable to resolve service for type &amp;#39;Microsoft.Extensions.Logging.ILogger&amp;#39; while attempting to activate &amp;#39;Some.Class&amp;#39;. 解决办法: 主要是由于构造函数依赖注入时使用了 ILogger 而不是 ILogger&amp;lt;&amp;gt; 导致的，故改为 ILogger&amp;lt;&amp;gt; 即可。</description></item><item><title>CSharp中发送HTTP请求的方法</title><link>https://www.zling.site/post/CSharp%E4%B8%AD%E5%8F%91%E9%80%81HTTP%E8%AF%B7%E6%B1%82%E7%9A%84%E6%96%B9%E6%B3%95/</link><pubDate>Fri, 02 Jul 2021 12:49:27 +0800</pubDate><guid>https://www.zling.site/post/CSharp%E4%B8%AD%E5%8F%91%E9%80%81HTTP%E8%AF%B7%E6%B1%82%E7%9A%84%E6%96%B9%E6%B3%95/</guid><description>发送 Get 请求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // HttpClient is intended to be instantiated once per application, rather than per-use. See Remarks. static readonly HttpClient client = new HttpClient(); static async Task Main() { // Call asynchronous network methods in a try/catch block to handle exceptions. try { HttpResponseMessage response = await client.GetAsync(&amp;#34;http://www.contoso.com/&amp;#34;); response.EnsureSuccessStatusCode(); string responseBody = await response.Content.ReadAsStringAsync(); // Above three lines can be replaced with new helper method below // string responseBody = await client.GetStringAsync(uri); Console.WriteLine(responseBody); } catch(HttpRequestException e) { Console.WriteLine(&amp;#34;\nException Caught!&amp;#34;); Console.WriteLine(&amp;#34;Message :{0} &amp;#34;,e.Message); } } 发送 Post 请求 1 2 3 4 5 6 7 8 9 10 11 using (var httpClient = new HttpClient { BaseAddress = new Uri(cqcPlatformUrl) }) { httpClient.DefaultRequestHeaders.Add(&amp;#34;Test&amp;#34;, &amp;#34;TestValue&amp;#34;);</description></item><item><title>AspNetCore控制器的Action返回结果类型</title><link>https://www.zling.site/post/AspNetCore%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84Action%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%B1%BB%E5%9E%8B/</link><pubDate>Fri, 02 Jul 2021 12:48:31 +0800</pubDate><guid>https://www.zling.site/post/AspNetCore%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84Action%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%B1%BB%E5%9E%8B/</guid><description>特定类型(Specific type) Action可返回原始类型或复杂类型对象（例如 string 或 自定义类型）。以下代码显示返回自定义的Product类型对象： 1 2 3 [HttpGet] public List&amp;lt;Product&amp;gt; Get() =&amp;gt; _repository.GetProducts(); 当同时返回多个对象时，需要返回 ActionResult 类型的对象，将其与前边的多个对象整合。 返回 IEnumerable 或 IAsyncEnumerable 类型 在 3.0 及之后的版本中返回 IAsyncEnumerable 类型结果 不会导</description></item><item><title>CSharp调用非托管C++时使用回调函数遇到的问题</title><link>https://www.zling.site/post/CSharp%E8%B0%83%E7%94%A8%E9%9D%9E%E6%89%98%E7%AE%A1C++%E6%97%B6%E4%BD%BF%E7%94%A8%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 07 Jun 2021 16:36:57 +0800</pubDate><guid>https://www.zling.site/post/CSharp%E8%B0%83%E7%94%A8%E9%9D%9E%E6%89%98%E7%AE%A1C++%E6%97%B6%E4%BD%BF%E7%94%A8%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</guid><description>如果该回调函数会被定时调用时，C#代码需要将回调函数对应的委托实例化成一个静态变量后使用，以避免 GC 将委托释放导致的异常问题。 参考：https://stackoverflow.com/questions/61985465/passing-c-sharp-callback-metho</description></item><item><title>CSharp中用线程安全的方式引发事件</title><link>https://www.zling.site/post/CSharp%E4%B8%AD%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E5%BC%95%E5%8F%91%E4%BA%8B%E4%BB%B6/</link><pubDate>Sat, 29 May 2021 23:47:02 +0800</pubDate><guid>https://www.zling.site/post/CSharp%E4%B8%AD%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E5%BC%95%E5%8F%91%E4%BA%8B%E4%BB%B6/</guid><description>在不考虑线程安全的情况下常常会写如下引发事件的代码: 1 2 3 4 5 6 7 // 版本1 public event EventHandle&amp;lt;EventArgs&amp;gt; Something; protected virtual void OnSomething(EventArgs e) { if(Something != null) Something(this, e); } 以上代码在单线程环境下能够正常运行，但是在多线程环境下就有可能导致问题。虽然对 Something 做了空引用的判断，但是在调用 Something 前有可能被另一个线程从委托链中移除委托，使得 Something 为空，导致空引用调</description></item><item><title>CSharp中的XML序列化</title><link>https://www.zling.site/post/CSharp%E4%B8%AD%E7%9A%84XML%E5%BA%8F%E5%88%97%E5%8C%96/</link><pubDate>Sat, 24 Apr 2021 22:04:09 +0800</pubDate><guid>https://www.zling.site/post/CSharp%E4%B8%AD%E7%9A%84XML%E5%BA%8F%E5%88%97%E5%8C%96/</guid><description>可 XML 序列化的内容 公有类的公有可读写属性和字段 接口 ICollection 或 IEnumerable 的实现类 XmlElement 对象 XmlNode 对象 DataSet 对象 XML 使用的 Attribute 通常 Xml 元素的名称由类名或成员名称，但是也可以通过 Attribute 去控制。 XmlArrayAttribute 和 XmlArrayItemAttribute XmlArrayAttribute 和 XmlArrayItemAttribute 用于控制数组的序列化。 XmlArrayAttribute 可以指定数组序列化时的 Xml元素名称。 1 2 3 4 public class Group { [XmlArray(&amp;#34;TeamMembers&amp;#34;)] public Employee[] Employees; } 1 2 3 4 5 6 7 &amp;lt;Group&amp;gt; &amp;lt;TeamMembers&amp;gt; &amp;lt;!-- 如果没有指定</description></item><item><title>CSharp的Environment类</title><link>https://www.zling.site/post/CSharp%E7%9A%84Environment%E7%B1%BB/</link><pubDate>Wed, 07 Apr 2021 18:39:41 +0800</pubDate><guid>https://www.zling.site/post/CSharp%E7%9A%84Environment%E7%B1%BB/</guid><description>1 var ev = Environment.GetEnvironmentVariable(&amp;#34;ev&amp;#34;);</description></item><item><title>CSharp中的压缩和解压</title><link>https://www.zling.site/post/CSharp%E4%B8%AD%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B/</link><pubDate>Mon, 05 Apr 2021 17:28:17 +0800</pubDate><guid>https://www.zling.site/post/CSharp%E4%B8%AD%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B/</guid><description>压缩和解压相关类 在 System.IO.Compression 中包含了有关压缩和解压的类： ZipFile ZipArchive ZipArchiveEntry DeflateStream GZipStream 文件的压缩和解压 流的压缩和解压</description></item><item><title>AspNetCore学习记录(1)</title><link>https://www.zling.site/post/AspNetCore%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</link><pubDate>Fri, 26 Mar 2021 22:19:59 +0800</pubDate><guid>https://www.zling.site/post/AspNetCore%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</guid><description>配置MVC 修改Startup文件成如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 using Microsoft.AspNetCore.Builder; using Microsoft.AspNetCore.Hosting; using Microsoft.AspNetCore.Http; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Hosting; namespace MockSchool { public class Startup { public void ConfigureServices(IServiceCollection services) { // 设置 EnableEndpointRouting 为 false 是为了使用 MVC 默认路由 //services.AddMvc(a =&amp;gt; a.EnableEndpointRouting = false); // 使用 AddControllersWithViews 而不使用 AddMvc 是为了不引入 RazorPages // 等未用到的服务 services.AddControllersWithViews(a =&amp;gt; a.EnableEndpointRouting = false); } public void Configure(IApplicationBuilder app, IWebHostEnvironment env) {</description></item></channel></rss>