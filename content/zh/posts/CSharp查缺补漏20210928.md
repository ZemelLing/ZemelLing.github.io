---
title: "CSharp查缺补漏20210928"
date: 2021-09-28T15:52:28+08:00
draft: false
tags: ["CSharp", ]
categories: ["CSharp",]
series:
description:
toc: true
authors:
  - zemelling
lastmod: 2021-09-28T15:52:28+08:00
featuredImage:
---

# c# 7.0 特性

## 数字字面量的改进

数字字面量可以使用下划线来改善可读性、它们称为数字分隔符而被编译器忽略

```C#
int million = 1_000_000;

var b = 0b1010_1011_1100_1101_1110_1111; // 二进制字面量可以使用0b前缀进行标识
```

## 解构器

解构方法的名字必须为Deconstruct，并且拥有一个或多个out参数

```c#
class Rectangle
{
    public readonly float Width, Height;
    public Rectangle(float width, float height)
    {
        Width = width;
        Height = height;
    }

    public void Deconstruct(out float width, out float height)
    {
        width = Width;
        height = Height;
    }
}
```

若要调用解构器，则需使用如下的特殊语法

```c#

var rect = new Rectangle(3, 4);
(float width, float height) = rect; // width = 3, height = 4
(var w, var h) = rect; // 解构器支持隐式推断

```

# 类

## 重载构造器

当构造器调用另一个构造器时，被调用的构造器先执行。

## 当构造器调用另一个构造器时，被调用的构造器先执行。

当构造器调用另一个构造器时，被调用的构造器先执行。

## 参量

常量是一种值永远不会改变的静态字段。常量会在编译时静态赋值，编译器会在常量使用点上直接替换该值（类似于C++的宏）。

```c#
public static double Circumference(double radius)
{
    return 2 * System.Math.PI * radius;
}

// 编译后等价于

public static double Circumference(double radius)
{
    return 6.2831583071795862 * radius;
}
```

## 静态构造器

每个类型的静态构造器只会执行一次，而不是每个实例执行一次。一个类型只能定义一个静态构造器，名称必须和类型同名，且没有参数

运行时将在类型使用之前调用静态构造器，以下两种行为可以触发静态构造器执行：
* 实例化类型
* 访问类型的静态成员

静态构造器只支持两个修饰符：unsafe和extern

### 静态构造器和字段初始化顺序

静态字段初始化器会在调用静态构造器前运行。如果类型没有静态构造器，字段会在类型被使用之前或者在运行时中更早的时间进行初始化。

静态字段初始化器按照字段声明的先后顺序运行。

# 继承

## new和重写的区别

```c# 
public class BaseClass
{
    public virtual void Foo() {Console.WriteLine("BaseClass.Foo");}
}

public class Overrider : BaseClass
{
    public override void Foo() {Console.WriteLine("Overrider.Foo");}
}

public class Hider : BaseClass
{
    public new void Foo() {Console.WriteLine("Hider.Foo");}
}

// test
Overrider over = new Overrider();
BaseClass b1 = over;
over.Foo();    // Overrider.Foo
b1.Foo();     // Overrider.Foo

Hider h = new Hider();
BaseClass b2 = h;
h.Foo();    // Hider.Foo
b2.Foo();    // BaseClass.Foo
```

## 构造器和继承

子类必须声明自己的构造器。派生类可以访问基类的构造器，但是并非自动继承。

基类的构造器总是先执行，这保证了基类的初始化发生在子类特定的初始化之前。

如果子类的构造器省略base关键字，那么基类的无参数构造器将被隐式调用。

如果基类没有可访问的无参数的构造器，子类的构造器中就必须使用base关键字。

### 构造器和字段初始化的顺序

* 1 从子类到基类
    * 1.1 初始化字段
    * 1.2 计算被调用的基类构造器中的参数
* 2 从基类到子类
    * 2.1 构造器方法体的执行

例如：
```c#
public class BaseClass
{
    int x = 1;  // 第三步
    public BaseClass(int x)
    {
        //something // 第四步
    }
}

public class SubClass : BaseClass
{
    int y = 1;  // 第一步
    public SubClass(int x) :
        base(x + 1) // 第二步
    {
        // something // 第五步
    }
}
```

# Object类型

## 装箱和拆箱的缺点

* 开销大，存在内存复制操作
* 拆箱时如果类型错误，只会在运行时发现

## GetType和typeof

* GetType在运行时计算而typeof在编译时静态计算（如果是用泛型类型参数，那么它将由即时编译器解析）

# 结构体

## 结构体的构造语义

* 结构体隐式包含一个无法重写的无参数构造器，将字段按位置为0。
* 定义结构体的构造器时，必须显式为每一个字段赋值

## 其他

* 结构体不支持字段初始化器

# 可访问性

## 友元程序集

在一些高级的场景中，添加System.Runtime.CompilerServices.InternalsVisibleTo程序集特性就可以将internal成员提供给其他的友元程序集访问

```c#
[assembly:InternalsVisibleTo("Friend")]
```

如果友元程序集有强名称，必须指定其完整的160字节公钥

```c#
[assembly:InternalsVisibleTo("StrongFriend, PublicKey=00241ffa...")]

// 获取强名称程序集的公钥
string key = string.Join("", Assembly.GetExecutingAssembly().GetName().GetPublicKey().Select(b => b.ToString("x2")));
```

# 接口

显式实现的接口成员不能标识为virtual，也不能实现通常意义的重写，但是它可以被重新实现（reimplemented）。

## 在子类中重新实现接口

子类可以重新实现基类实现的任意一个接口成员。不管基类中该成员是否为virtual，当通过接口调用时，重新实现都能够劫持成员的实现。它对接口成员的隐式和显式实现都有效，但后者效果更好。

```c#
public interface IUndoable {void Undo();}

public class TextBox : IUndoable
{
    void IUndoable.Undo() => Console.WriteLine("TextBox.Undo");
}

public class RichTextBox : TextBox, IUndoable
{
    public void Undo() => Console.WriteLine("RichTextBox.Undo");
}

// 从接口调用重新实现的成员时，调用的是子类的实现
RichTextBox r = new RichTextBox();
r.Undo();    // RichTextBox.Undo
((IUndoable)r).Undo();    // RichTextBox.Undo
```

通过重新实现来劫持调用的方式仅在通过接口调用成员时有效，而从基类调用时无效。这个特性通常不尽人意，因为它有二义性。因此，重新实现主要适合于重写显式实现的接口成员

## 接口重新实现的替代方法

即使是显式实现的成员，接口重新实现还是容易出问题，这是因为
* 子类无法调用基类的方法 
* 定义基类时不能预测方法是否会重新实现，或无法接受重新实现后的潜在问题

重新实现是子类未知时的最不理想的方法。更好的选择是在定义基类时不允许使用重新实现，有两种方法可以做到
* 当隐式实现成员时，如果需要将其标记为virtual
* 当显式实现成员时，如果能够预测子类可能要重写某些逻辑，则使用下面的模式

```c#
public class TextBox : IUndoable
{
    void IUndoable.Undo() => Undo();
    protected virtual void Undo() => Console.WriteLine("TextBox.Undo");
}

public class RichTextBox : TextBox
{
    protected override void Undo() => Console.WriteLine("RichTextBox.Undo");
}
```

## 接口与装箱

将结构体转换为接口会引发装箱。而调用结构体的隐式实现接口成员不会引发装箱。

```c#
interface I {void Foo();}
struct S : I {void Foo();}

S s = new S();
s.Foo();  // 没有装箱

I i = s;  // 装箱
i.Foo();
```

# 枚举类型



# 阅读书本

[C# 7.0核心技术指南（原书第7版）](https://weread.qq.com/web/reader/710327c0718f6368710b285kc81322c012c81e728d9d180)