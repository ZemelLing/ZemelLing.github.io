<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>游戏开发 on 泽梅尔的驻留地</title><link>https://www.zling.site/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/</link><description>Recent content in 游戏开发 on 泽梅尔的驻留地</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 27 Nov 2021 19:42:30 +0800</lastBuildDate><atom:link href="https://www.zling.site/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/index.xml" rel="self" type="application/rss+xml"/><item><title>Unity资源常用目录和路径大总结</title><link>https://www.zling.site/post/Unity%E8%B5%84%E6%BA%90%E5%B8%B8%E7%94%A8%E7%9B%AE%E5%BD%95%E5%92%8C%E8%B7%AF%E5%BE%84%E5%A4%A7%E6%80%BB%E7%BB%93/</link><pubDate>Sat, 27 Nov 2021 19:42:30 +0800</pubDate><guid>https://www.zling.site/post/Unity%E8%B5%84%E6%BA%90%E5%B8%B8%E7%94%A8%E7%9B%AE%E5%BD%95%E5%92%8C%E8%B7%AF%E5%BE%84%E5%A4%A7%E6%80%BB%E7%BB%93/</guid><description>转载自：Unity资源常用目录和路径大总结 参考1：unity不同平台下的路径和读写权限 参考2：#你好Unity3D#手机上的路径（来自我的长微博） 参考3：Unity3D研究院之Android同步方法读取streamingAssets（八十八） 一、资源路径 字段 说明 Application.dataPath 包含游戏在目标平</description></item><item><title>ToLua项目配置</title><link>https://www.zling.site/post/ToLua%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/</link><pubDate>Sun, 31 Oct 2021 09:39:02 +0800</pubDate><guid>https://www.zling.site/post/ToLua%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/</guid><description>将 ToLua 下的 Assets 和 Luac53 文件夹复制到自己的工程 前往 https://github.com/topameng/tolua_runtime 将Plugins53文件夹里面的所有tolua相关的runtime底层库，都拷贝覆盖到unity工程的Plugins目录下。 打开unity编辑器，添加“LUAC_5_3”宏，回车等待编辑器编译完毕既是Lua5.3的虚拟机环境。 注意要用lu</description></item><item><title>Lua名词解释</title><link>https://www.zling.site/post/Lua%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/</link><pubDate>Sun, 31 Oct 2021 08:52:28 +0800</pubDate><guid>https://www.zling.site/post/Lua%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/</guid><description>Lua lua其实就是为了嵌入其它应用程序而开发的一个脚本语言， lua优势 1）lua是一个免费、小巧、简单、强大、高效、轻量级的嵌入式的脚本语言 2）它是用C语言开发的项目，所以可以在大部分的操作系统上运行 3）lua是目前速度最快的脚本语言，既可以提升语言的灵活性还可以最大限度的保留速度</description></item><item><title>Unity中的UGUI</title><link>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84UGUI/</link><pubDate>Wed, 27 Oct 2021 19:26:14 +0800</pubDate><guid>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84UGUI/</guid><description>基本组件 Text 需要使用TTF字体，RaycastTarget选项决定组件是否响应点击事件。可使用 Outline 和 Shadow 组件为文本描边和添加阴影。描边的效率低于阴影。 Image 图片类型（Image Type）分为四种： Simple 直接显示图片 Sliced 通过九宫格方式显示图片，可用 SpriteEditor 来编辑九宫格的区域 Tiled 平铺图片 Filled 像技能CD一样，可</description></item><item><title>Unity中的IMGUI</title><link>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84IMGUI/</link><pubDate>Mon, 25 Oct 2021 11:18:17 +0800</pubDate><guid>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84IMGUI/</guid><description>什么是 IMGUI 即时模式 GUI 系统（也称为 IMGUI）是一个完全独立的功能系统，不同于 Unity 基于游戏对象的主 UI 系统，IMGUI 需在实现脚本上调用 OnGUI 函数，并在其中实现绘制 UI 的代码。 IMGUI 作用 创建游戏内调试显示和工具。 为脚本组件创建自定义检视面板。 创建新的编辑器窗口和工具以扩展 Unity 本身。 控件 Label Button RepeatButton TextField TextArea Toggle ToolBar</description></item><item><title>Unity之动态将场景添加到BuildSettings中</title><link>https://www.zling.site/post/Unity%E4%B9%8B%E5%8A%A8%E6%80%81%E5%B0%86%E5%9C%BA%E6%99%AF%E6%B7%BB%E5%8A%A0%E5%88%B0BuildSettings%E4%B8%AD/</link><pubDate>Sat, 11 Sep 2021 19:07:09 +0800</pubDate><guid>https://www.zling.site/post/Unity%E4%B9%8B%E5%8A%A8%E6%80%81%E5%B0%86%E5%9C%BA%E6%99%AF%E6%B7%BB%E5%8A%A0%E5%88%B0BuildSettings%E4%B8%AD/</guid><description>代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #region 将场景添加到 Build Settings // 场景存放目录 var sceneDir = $&amp;#34;{Application.dataPath}/Scenes&amp;#34;; var sceneFiles = Directory.GetFiles(sceneDir, &amp;#34;*.unity&amp;#34;, SearchOption.AllDirectories); var scenes = new EditorBuildSettingsScene[sceneFiles.Length]; for (var i = 0; i &amp;lt; sceneFiles.Length; i++) { // 替换斜杠 var sceneFile = sceneFiles[i].Replace(&amp;#34;\\&amp;#34;, &amp;#34;/&amp;#34;); // 使用相对路径 var assetsFolderIndex = sceneFile.IndexOf(&amp;#34;Assets&amp;#34;, StringComparison.Ordinal); sceneFile = sceneFile.Substring(assetsFolderIndex); var scene = new EditorBuildSettingsScene(sceneFile, true); scenes[i] = scene; } EditorBuildSettings.scenes = scenes; #endregion</description></item><item><title>Unity中使用Addressable</title><link>https://www.zling.site/post/Unity%E4%B8%AD%E4%BD%BF%E7%94%A8Addressable/</link><pubDate>Mon, 06 Sep 2021 18:56:37 +0800</pubDate><guid>https://www.zling.site/post/Unity%E4%B8%AD%E4%BD%BF%E7%94%A8Addressable/</guid><description>使用步骤 标记资源为Addressable 方式一：在资源的Inspector界面 方式二：在 Addressables Groups 窗口 构建可寻址内容(Addressable Content) 方式一：使用 Editor 在 Addressables Groups 窗口右上角选择 Build &amp;gt; New Build &amp;gt; Default Build Script. 方式二：使用脚本 API AddressableAssetSettings.BuildPlayerContent() 使用 Addressable 资源 方式一：通过 address 加载或实例化资源 加载资源 Addressables.LoadAssetAsync&amp;lt;GameObject&amp;gt;(&amp;quot;AssetAddress&amp;quot;); 实例化资源 Addressables.InstantiateAsync(&amp;quot;AssetAddress&amp;quot;); 示例： 1 2 3</description></item><item><title>Unity代码修改Prefab未能保存的问题</title><link>https://www.zling.site/post/Unity%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9Prefab%E6%9C%AA%E8%83%BD%E4%BF%9D%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 06 Sep 2021 15:37:19 +0800</pubDate><guid>https://www.zling.site/post/Unity%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9Prefab%E6%9C%AA%E8%83%BD%E4%BF%9D%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98/</guid><description>解决办法 使用 EditorUtility.SetDirty(thePrefabObjectOrComponent); 将其设置为Dirty，之后就可以保存了。</description></item><item><title>Unity中使用CustomEditor自定义脚本的Inspector面板</title><link>https://www.zling.site/post/Unity%E4%B8%AD%E4%BD%BF%E7%94%A8CustomEditor%E8%87%AA%E5%AE%9A%E4%B9%89%E8%84%9A%E6%9C%AC%E7%9A%84Inspector%E9%9D%A2%E6%9D%BF/</link><pubDate>Sun, 05 Sep 2021 20:43:12 +0800</pubDate><guid>https://www.zling.site/post/Unity%E4%B8%AD%E4%BD%BF%E7%94%A8CustomEditor%E8%87%AA%E5%AE%9A%E4%B9%89%E8%84%9A%E6%9C%AC%E7%9A%84Inspector%E9%9D%A2%E6%9D%BF/</guid><description>自定义脚本 1 2 3 4 5 6 7 8 9 10 using UnityEngine; public class LookAtPoint : MonoBehaviour { public Vector3 lookAtPoint = Vector3.zero; void Update() { transform.LookAt(lookAtPoint); } } 使用 CustomEditor 特性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 using UnityEngine; using UnityEditor; [CustomEditor(typeof(LookAtPoint))] // 指定为哪个组件自定义编辑器界面 [CanEditMultipleObjects] // 指示Unity可以为多个对象的同一组件同时编辑 public class LookAtPointEditor : Editor { SerializedProperty lookAtPoint;</description></item><item><title>Unity中的Transform组件</title><link>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84Transform%E7%BB%84%E4%BB%B6/</link><pubDate>Sun, 05 Sep 2021 11:24:21 +0800</pubDate><guid>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84Transform%E7%BB%84%E4%BB%B6/</guid><description>Transform组件 在 Unity 场景中的游戏对象都有 Transform 组件，用于存储和操作对象的位置、旋转和缩放，同时 Transform 支持枚举。 重要的属性 属性 说明 childCount 该transform的直接孩子个数 forward 返回归一化向量，该向量在世界空间中为蓝色轴表示 right 红色轴 up 绿色轴 重要的方法 方法 说明 DetachChildren 将当前 Transform 下的孩子与其脱钩 Find 根据给定</description></item><item><title>Unity的RuntimeInitializeOnLoadMethodAttribute特性</title><link>https://www.zling.site/post/Unity%E7%9A%84RuntimeInitializeOnLoadMethodAttribute%E7%89%B9%E6%80%A7/</link><pubDate>Wed, 01 Sep 2021 15:27:16 +0800</pubDate><guid>https://www.zling.site/post/Unity%E7%9A%84RuntimeInitializeOnLoadMethodAttribute%E7%89%B9%E6%80%A7/</guid><description>RuntimeInitializeOnLoadMethodAttribute 被标记为 RuntimeInitializeOnLoadMethodAttribute 的方法在游戏加载后就被调用，同时在Awake之后调用。 同时需要注意的是，所有被标记为 RuntimeInitializeOnLoadMethodAttribute 的方法，它们之间被调用的顺序是不一定的。 同时该特性还拥有可选参数 loadType，该参数决定了被标记的方法是在场景加载前还是加载后被调用。</description></item><item><title>Unity中使用Null合并操作符和Null条件操作符时的注意事项</title><link>https://www.zling.site/post/Unity%E4%B8%AD%E4%BD%BF%E7%94%A8Null%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8CNull%E6%9D%A1%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link><pubDate>Mon, 30 Aug 2021 08:37:49 +0800</pubDate><guid>https://www.zling.site/post/Unity%E4%B8%AD%E4%BD%BF%E7%94%A8Null%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8CNull%E6%9D%A1%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid><description>Unity中使用??和?.操作符时的注意事项 不要在继承自 UnityEngine.Object 的对象上使用 这是由于这些操作符并不使用由 UnityEngine.Object 重载的相等操作符，因此有可能导致意外通过 Unity 的生命周期检查。这种情况下最好使用显示Null判断或调用 System.Object.ReferenceEquals 函数。 具体可参考JetBrains提供的这篇文章 &amp;ldquo;Possible unintended bypass of lifetime check of underlying Unity engine object&amp;rdquo;</description></item><item><title>Unity中游戏对象产生碰撞的条件</title><link>https://www.zling.site/post/Unity%E4%B8%AD%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E4%BA%A7%E7%94%9F%E7%A2%B0%E6%92%9E%E7%9A%84%E6%9D%A1%E4%BB%B6/</link><pubDate>Tue, 22 Jun 2021 22:29:17 +0800</pubDate><guid>https://www.zling.site/post/Unity%E4%B8%AD%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E4%BA%A7%E7%94%9F%E7%A2%B0%E6%92%9E%E7%9A%84%E6%9D%A1%E4%BB%B6/</guid><description>其中至少一个物体（必须运动的）必须带有碰撞器（collider）+刚体(Rigidbody)，另一个物体（可以静止也可以运动）也必须至少带有collider 静态碰撞器 没有刚体而有碰撞器的物体，此时该碰撞器就是静态碰撞器。 刚体碰撞器 如果游戏对象既有刚体又有碰撞器，则该碰撞器为刚体碰</description></item><item><title>Unity中的欧拉角和四元数</title><link>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84%E6%AC%A7%E6%8B%89%E8%A7%92%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/</link><pubDate>Tue, 01 Jun 2021 17:18:09 +0800</pubDate><guid>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84%E6%AC%A7%E6%8B%89%E8%A7%92%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/</guid><description>在 Unity 有两种方式用于表示旋转，欧拉角和四元数。其中欧拉角用于查看和编辑，引擎内部使用四元数来表示。 欧拉角 欧拉角具有三个数字，分别表示绕 x 轴、y 轴和 z 轴旋转的角度。当使用欧拉角旋转物体时，需要按照某个特定的顺序依次绕轴旋转，才能够正确旋转。其最主要的问题是会导致万向锁。 万向锁问题 参考</description></item><item><title>Unity中的Tilemap</title><link>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84Tilemap/</link><pubDate>Tue, 18 May 2021 15:06:16 +0800</pubDate><guid>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84Tilemap/</guid><description>用法 导入图片资源，并将其 Texture Type 设置为 (2D Sprite and UI) 创建 Tilemap 打开 TilePalette 窗口，创建 Palette Grid Grid 对象用于对齐瓦片等对象。 TileMap Tile RuleTile RuleTile的Inspection界面存在一个九宫格用于配置Tile的绘制规则。中心表示当前的Tile，其它八个方向表示相邻的其它Tile。 选项 图标 描述 Don&amp;rsquo;t Care 空白 Rule Tile 会忽略这个位</description></item><item><title>Unity中的Sprites</title><link>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84Sprites/</link><pubDate>Mon, 17 May 2021 20:32:36 +0800</pubDate><guid>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84Sprites/</guid><description>什么是 Sprites Sprites 是 2D 图形对象，在 3D 中本质是标准纹理。 Unity 中的 Sprite 工具 Sprite Creator 用于创建占位用的 Sprite，之后有具体的素材后再替换。 Sprite Editor 用于从一张图片或纹理中切割出多个 Sprite。通常会将关联的 Sprite 放入一张图片中，以形成图集，降低资源消耗。 Sprite Packer 使用Sprite Packer可以优化项目对视频内存</description></item><item><title>不会做游戏之2d游戏地图</title><link>https://www.zling.site/post/%E4%B8%8D%E4%BC%9A%E5%81%9A%E6%B8%B8%E6%88%8F%E4%B9%8B2d%E6%B8%B8%E6%88%8F%E5%9C%B0%E5%9B%BE/</link><pubDate>Sun, 16 May 2021 17:21:16 +0800</pubDate><guid>https://www.zling.site/post/%E4%B8%8D%E4%BC%9A%E5%81%9A%E6%B8%B8%E6%88%8F%E4%B9%8B2d%E6%B8%B8%E6%88%8F%E5%9C%B0%E5%9B%BE/</guid><description>生成2d地图的方式 整体绘制 瓷砖式拼接（Tilemap） 算法生成 使用 Tilemap 创建 2d 地图</description></item><item><title>不会写游戏文档</title><link>https://www.zling.site/post/%E4%B8%8D%E4%BC%9A%E5%86%99%E6%B8%B8%E6%88%8F%E6%96%87%E6%A1%A3/</link><pubDate>Fri, 14 May 2021 17:44:14 +0800</pubDate><guid>https://www.zling.site/post/%E4%B8%8D%E4%BC%9A%E5%86%99%E6%B8%B8%E6%88%8F%E6%96%87%E6%A1%A3/</guid><description>文档的种类 单页说明书 十页说明书 游戏流程表 游戏设计文档 单页说明书 单页说明书是对游戏的一个概括总览。 内容 游戏名称 游戏系统 目标玩家年龄 预计 ESRB 分级 游戏故事概要，着重描述可玩性 游戏玩法的独特性 与众不同的卖点 竞品 十页说明书 第一页：游戏名称 游戏名 游戏系统 目标玩家年龄 预计 ESRB 定级 计划发行日期 第二页</description></item><item><title>Unity中的RuntimeRuntimeInitializeOnLoadMethodAttribute</title><link>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84RuntimeRuntimeInitializeOnLoadMethodAttribute/</link><pubDate>Mon, 26 Apr 2021 22:27:49 +0800</pubDate><guid>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84RuntimeRuntimeInitializeOnLoadMethodAttribute/</guid><description>被此特性标注的方法将在 Awake 方法之后被 Unity 循环调用，而且被此特性标记的所有方法，它们之间的执行顺序不是固定的。 示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 using UnityEngine; public class MyTest : MonoBehaviour { [RuntimeInitializeOnLoadMethod] static void OnRuntimeMethodLoad() { Debug.Log(&amp;#34;After Scene is loaded and game is running&amp;#34;); } [RuntimeInitializeOnLoadMethod] static void OnSecondRuntimeMethodLoad() { Debug.Log(&amp;#34;SecondMethod After Scene is loaded and game is running.&amp;#34;); } private void Awake() { Debug.Log(&amp;#34;Awake method&amp;#34;); } private void Start() { Debug.Log(&amp;#34;Start method&amp;#34;); } } 结果：</description></item><item><title>Unity中的资源系统</title><link>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E7%B3%BB%E7%BB%9F/</link><pubDate>Thu, 15 Apr 2021 12:15:15 +0800</pubDate><guid>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E7%B3%BB%E7%BB%9F/</guid><description>资源 Unity通过将资源的唯一 ID 写入与资源同名的 .meta 文件来确保对资源的唯一引用。 新增的资源 Unity 都会创建与之对应的 .meta 文件 Unity 读取并处理 Assets 文件夹中的任何文件，并将其转换成可直接用于游戏内容的数据格式，存储在 Libraray 文件夹中，而原文件仍然保留在 Assets 文件夹中 .meta 文件不止包含资源 ID 同时也包含资源导入设置的</description></item><item><title>Unity中事件函数的执行顺序</title><link>https://www.zling.site/post/Unity%E4%B8%AD%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</link><pubDate>Wed, 14 Apr 2021 09:37:25 +0800</pubDate><guid>https://www.zling.site/post/Unity%E4%B8%AD%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</guid><description>阶段 主要阶段 初始化阶段，包含 Awake() Start() 物理系统更新阶段，包含 FixedUpdate()、动画更新、OnTriggerXXX、OnCollisionXXX，物理系统可能一帧内更新多次。 输入事件，OnMouseXXX 游戏逻辑阶段，Update、从协程恢复、动画更新、LateUpdate 游戏</description></item><item><title>Unity中引用第三方程序集</title><link>https://www.zling.site/post/Unity%E4%B8%AD%E5%BC%95%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E7%A8%8B%E5%BA%8F%E9%9B%86/</link><pubDate>Mon, 05 Apr 2021 22:32:04 +0800</pubDate><guid>https://www.zling.site/post/Unity%E4%B8%AD%E5%BC%95%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E7%A8%8B%E5%BA%8F%E9%9B%86/</guid><description>在 Unity 中是通过插件（注意，此处的插件特指预编译的程序集或原生库，与编辑器插件代码区分开）的形式引用第三方程序集或原生库，其中引用的 .NET 程序集称作托管插件，原生库为原生插件。 插件的存放位置影响其导入设置 文件夹 默认设置 Assets/../Editor 将插件设置为仅与 Editor 兼容，在构建到平台时不会使用。 Assets/../</description></item><item><title>Unity中的项目设置说明</title><link>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE%E8%AF%B4%E6%98%8E/</link><pubDate>Mon, 05 Apr 2021 14:11:24 +0800</pubDate><guid>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE%E8%AF%B4%E6%98%8E/</guid><description>项目设置 Edit &amp;gt; Project Settings 此处打开项目设置窗口。 Player Player 界面用于设置最终生成的游戏包相关的设置。多数与具体平台有关。 Android Other Settings Configuration API Compatibility Level .Net Standard 2.0 兼容 .NET Standard 2.0。生成较小的构建并具有完整的跨平台支持。 兼容 .NET Framework 4（包括 .NET Standard 2.0 配置文件中的所有内容以及其他 API）。如果使用的库需要访问 .NET Standard 2.0 中未包含的 API，</description></item><item><title>Unity中的特殊文件夹和脚本编译顺序</title><link>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E5%A4%B9%E5%92%8C%E8%84%9A%E6%9C%AC%E7%BC%96%E8%AF%91%E9%A1%BA%E5%BA%8F/</link><pubDate>Mon, 05 Apr 2021 13:24:47 +0800</pubDate><guid>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E5%A4%B9%E5%92%8C%E8%84%9A%E6%9C%AC%E7%BC%96%E8%AF%91%E9%A1%BA%E5%BA%8F/</guid><description>特殊文件夹 Assets Assets 文件夹是包含 Unity 项目使用的资源的主文件夹。Editor 中的 Project 窗口的内容直接对应于 Assets 文件夹的内容。大多数 API 函数都假定所有内容都位于 Assets 文件夹中，因此不要求显式提及该文件夹。但是，有些函数需要将 Assets 文件夹作为路径名的一部分添加（例如，AssetDatabase 类中的一些函数）</description></item><item><title>Unity中的程序集定义</title><link>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84%E7%A8%8B%E5%BA%8F%E9%9B%86%E5%AE%9A%E4%B9%89/</link><pubDate>Mon, 05 Apr 2021 13:15:45 +0800</pubDate><guid>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84%E7%A8%8B%E5%BA%8F%E9%9B%86%E5%AE%9A%E4%B9%89/</guid><description>程序集定义（Assembly Definitions） Unity 使用程序集定义和程序集引用（Assembly References）组织代码结构，同时 Unity 默认使用预定义的程序集，Assembly-CSharp.dll，来组织代码。 但是这种结构并不适合中大型项目，单一程序集将导致代码结构不够清晰</description></item><item><title>Unity中获取对象的方法</title><link>https://www.zling.site/post/Unity%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/</link><pubDate>Sun, 04 Apr 2021 17:39:33 +0800</pubDate><guid>https://www.zling.site/post/Unity%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/</guid><description>直接关联 在脚本中创建public的想要关联的游戏对象类型的变量，随后在inspector中关联对应的游戏对象即可 1 2 3 4 5 6 public class Enemy : MonoBehaviour { public GameObject player; // 其他变量和函数... } 子游戏对象 使用父游戏对象的变换组件来检索子游戏对象（因为所有游戏对象都具有隐式变换） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15</description></item><item><title>Unity中的资源加载</title><link>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD/</link><pubDate>Sun, 04 Apr 2021 16:18:57 +0800</pubDate><guid>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD/</guid><description>加载方式 将 Prefab 拖拽到 Inspector 的脚本上 这是最简单的方式，但是在实际项目中通常不使用，因为这种方式不够灵活，拖拽的方式低效，存在大量的隐式耦合。 1 2 3 4 5 6 7 8 9 public class Test : MonoBehaviour { public GameObject prefab; void Start() { var go = GameObject.Instantiate(prefab); } } 将 Prefab 放到 Resources 文件夹下，通过 Resources.Load 方法加载 这种方式实现也很简单，虽然比上一种方式好些，但实际项目中也不</description></item><item><title>Unity中的场景</title><link>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84%E5%9C%BA%E6%99%AF/</link><pubDate>Sun, 04 Apr 2021 16:18:51 +0800</pubDate><guid>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84%E5%9C%BA%E6%99%AF/</guid><description>Scene 场景是 Unity 中由于放置游戏对象和UI元素的资源文件。 创建场景 使用新建场景对话框（ New Scene Dialog）根据指定的场景模板创建场景。 使用菜单或项目窗口根据项目基本的场景模板创建场景（这是最常见的方式）。 Scene 模板 加载场景 无论是同步加载还是异步加载，都需要将 Scene 在 BuildSettings 中设置好。 同步加载场景 1 2 3 4</description></item><item><title>Unity中实现存档的方式</title><link>https://www.zling.site/post/Unity%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%AD%98%E6%A1%A3%E7%9A%84%E6%96%B9%E5%BC%8F/</link><pubDate>Sun, 04 Apr 2021 13:23:06 +0800</pubDate><guid>https://www.zling.site/post/Unity%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%AD%98%E6%A1%A3%E7%9A%84%E6%96%B9%E5%BC%8F/</guid><description>PlayerPrefs PlayerPrefs 是 Unity 中用于存储用户数据的类，且只能够存储一些基本类型数据。 存储路径 存储路径取决于所在操作系统。 Windows: 存在注册表的 HKCU\Software\ExampleCompanyName\ExampleProductName Key 下 Windows Store Apps: 存在 %userprofile%\AppData\Local\Packages[ProductPackageId]\LocalState\playerprefs.dat 文件里 macOS: ~/Library/Preferences/com.ExampleCompanyName.ExampleProductName.plist Linux: ~/.config/unity3d/ExampleCompanyName/ExampleProductName 静态方法 方法名 描述 DeleteAll Removes all keys and values from the preferences. Use with caution. DeleteKey Removes the given key from the PlayerPrefs. If the key does not exist, DeleteKey has no impact. GetFloat Returns the value corresponding to key in the preference file if it exists. GetInt Returns the value corresponding to key in the preference file if it exists. GetString</description></item><item><title>Unity中UGUI的自适应</title><link>https://www.zling.site/post/Unity%E4%B8%ADUGUI%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94/</link><pubDate>Sat, 03 Apr 2021 14:35:22 +0800</pubDate><guid>https://www.zling.site/post/Unity%E4%B8%ADUGUI%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94/</guid><description>设置 Canvas 的缩放模式为 Match Width Or Height 设置 Canvas 的 Match 为 Height（如果为横板游戏的话） 然后设置 UI 组件的锚点</description></item><item><title>Unity中的光照</title><link>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84%E5%85%89%E7%85%A7/</link><pubDate>Fri, 02 Apr 2021 16:11:55 +0800</pubDate><guid>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84%E5%85%89%E7%85%A7/</guid><description>Unity中的光照类型 直接光照和间接光照 直接光照指照射到物体表面只反射一次后就传入感应器的光照，而间接光照指光线经过多次反射后再传入感应器的关照，这两种光照 Unity 都可以通过计算获取。 实时光照和烘培光照 实时光照指 Unity 在运行时计算光照，而烘培光照指将预计算的光照信息存储后有 Unity 在运行时读取恢</description></item><item><title>Unity的Android开发环境配置</title><link>https://www.zling.site/post/Unity%E7%9A%84Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</link><pubDate>Fri, 02 Apr 2021 14:47:36 +0800</pubDate><guid>https://www.zling.site/post/Unity%E7%9A%84Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</guid><description>Android环境配置 添加 Android 开发相关组件 启用 USB 调试 将手机设置为开发者模式，具体机型可能有所不同，但通常都是连续点击设置里的 Build number 多次即可进入开发者模式。之后在开发者选项里启用 USB 调试。 其他 使用自定义的 SDK 路径 可在 Preferences &amp;gt; External tools 里设置自定义的 SDK等路径 调整 Android SDK Api Level Edit &amp;gt; Project Settings &amp;gt; Player 下可设置此选项</description></item><item><title>Unity中的渲染管线</title><link>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/</link><pubDate>Wed, 31 Mar 2021 16:30:07 +0800</pubDate><guid>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/</guid><description>一个渲染管线通过执行一系列操作获取场景中需要展示的内容并将其显示到场景中。这些操作包括： 剔除 渲染 后期处理 Unity提供的渲染管线 内置渲染管线 内置渲染管线是 Unity 的旧版渲染管线，并且不是基于可编程渲染管线实现的。 内容渲染管线可通过设置不同的渲染管线进行设置，同时可以通过命令缓存（Com</description></item><item><title>Unity中的RnderingPath</title><link>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84RnderingPath/</link><pubDate>Sat, 27 Mar 2021 19:06:07 +0800</pubDate><guid>https://www.zling.site/post/Unity%E4%B8%AD%E7%9A%84RnderingPath/</guid><description>什么是渲染路径 Unity的内置渲染管线支持不同的渲染路径，渲染路径表示了与光照和阴影相关的一系列操作。 何处设置渲染路径 在 Graphics 窗口 Camera 组件 渲染路径的类型 当前共存在四种渲染路径：Forward Rendering、Deferred Shading、Legacy Deferred、Legacy Vertex</description></item><item><title>Unity的Camera组件</title><link>https://www.zling.site/post/Unity%E7%9A%84Camera%E7%BB%84%E4%BB%B6/</link><pubDate>Sat, 27 Mar 2021 14:04:16 +0800</pubDate><guid>https://www.zling.site/post/Unity%E7%9A%84Camera%E7%BB%84%E4%BB%B6/</guid><description>透视模式和正交模式 Unity的相机存在两种相机投影模式，其中透视模式实现了现实世界的效果，即近大远小的透视效果，反之，无近大远小效果的为正交模式。 可视范围的形状 相机(Camera)组件 上图显示的是在内建渲染管线下相机的属性截图 属性 Clear Flags ClearFlags 用于清除相机不同的缓冲区信息集合。 Skybox 使用天空</description></item></channel></rss>