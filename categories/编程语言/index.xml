<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编程语言 on 泽梅尔的驻留地</title><link>https://www.zling.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</link><description>Recent content in 编程语言 on 泽梅尔的驻留地</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 25 Oct 2021 09:54:30 +0800</lastBuildDate><atom:link href="https://www.zling.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/index.xml" rel="self" type="application/rss+xml"/><item><title>CSharp查缺补漏之重写(override)和覆盖(new)的区别</title><link>https://www.zling.site/post/CSharp%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F%E4%B9%8B%E9%87%8D%E5%86%99%E5%92%8C%E8%A6%86%E7%9B%96%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 25 Oct 2021 09:54:30 +0800</pubDate><guid>https://www.zling.site/post/CSharp%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F%E4%B9%8B%E9%87%8D%E5%86%99%E5%92%8C%E8%A6%86%E7%9B%96%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>不管是重写还是覆盖都不会影响父类自身的功能（废话，肯定的嘛，除非代码被改）。 当用子类创建父类的时候，如 C1 c3 = new C2()，重写会改变父类的功能，即调用子类的功能；而覆盖不会，仍然调用父类功能。 虚方法、实方法都可以被覆盖（new），抽象方法，接口 不可以。 抽象方法，接口，标记为virt</description></item><item><title>CSharp查缺补漏20210928</title><link>https://www.zling.site/post/CSharp%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F20210928/</link><pubDate>Tue, 28 Sep 2021 15:52:28 +0800</pubDate><guid>https://www.zling.site/post/CSharp%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F20210928/</guid><description>c# 7.0 特性 数字字面量的改进 数字字面量可以使用下划线来改善可读性、它们称为数字分隔符而被编译器忽略 1 2 3 int million = 1_000_000; var b = 0b1010_1011_1100_1101_1110_1111; // 二进制字面量可以使用0b前缀进行标识 解构器 解构方法的名字必须为Deconstruct，并且拥有一个或多个out参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Rectangle { public readonly float Width, Height; public</description></item><item><title>使用Activator动态创建实例</title><link>https://www.zling.site/post/%E4%BD%BF%E7%94%A8Activator%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B/</link><pubDate>Mon, 27 Sep 2021 11:07:17 +0800</pubDate><guid>https://www.zling.site/post/%E4%BD%BF%E7%94%A8Activator%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B/</guid><description>Activator Activator 包含能够创建本地或远程类型对象或获取对现有远程对象的引用的方法。 重要的方法 CreateInstance 此方法通过调用与给定参数最匹配的类构造函数创建类的实例。默认情况下，如果被创建实例的类没有Public的构造函数或找不到匹配的构造函数，此方法将抛出异常。</description></item><item><title>Lua学习记录（三）</title><link>https://www.zling.site/post/Lua%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%89/</link><pubDate>Sun, 29 Aug 2021 14:44:11 +0800</pubDate><guid>https://www.zling.site/post/Lua%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%89/</guid><description>位和字节 位运算 运算符 操作 &amp;amp; 按位与 | 按位或 ~ 按位异或 &amp;laquo; 逻辑左移 &amp;raquo; 逻辑右移 ~ 按位取反（一元运算） Lua 中没有提供算术右移和左移，只提供了逻辑的。 无符号整数 Lua 中使用 math.ult 函数比较两个无符号整数的大小。 打包和解包二进制数据 string.pack 函数会把值打包成二进制数据 string.unpack 则反之 string.pack 和 string.unpack 的第一个参数是格式化字符串，函数</description></item><item><title>Lua学习记录（二）</title><link>https://www.zling.site/post/Lua%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%BA%8C/</link><pubDate>Sat, 28 Aug 2021 10:53:56 +0800</pubDate><guid>https://www.zling.site/post/Lua%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%BA%8C/</guid><description>模式匹配 函数 string.find 返回匹配的开始和结束索引 string.match 返回匹配的字符串 string.gsub 返回替换后的字符串和发生替换的次数 string.gmatch 返回函数，此函数可遍历一个字符串中所匹配的所有字串 模式 Lua 中模式使用百分号做转义字符。 字符分类 含义 . 任意字符 %a 任意字母 %c 控制字符 %d 数字 %g 除空格外的可打印字符 %l 小写字母 %p 标点符号 %s 空白字符 %u</description></item><item><title>Lua学习记录（一）</title><link>https://www.zling.site/post/Lua%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80/</link><pubDate>Wed, 18 Aug 2021 22:20:23 +0800</pubDate><guid>https://www.zling.site/post/Lua%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80/</guid><description>标识符 由任意字母、数字和下划线组成，同时首字符不能是数字，大小写敏感。 下划线加全大写字母（例如：_VERSION）组成的标识符，通常是特殊标识符（最好不要定义相同的标识符）。 一下是 lua 保留字 1 and break do else elseif end false goto for function if in local nil not or repeat return then true until while 注释 以下为单行注释 1 -- 单行注释 以下是多行注释 1</description></item><item><title>CSharp中发送HTTP请求的方法</title><link>https://www.zling.site/post/CSharp%E4%B8%AD%E5%8F%91%E9%80%81HTTP%E8%AF%B7%E6%B1%82%E7%9A%84%E6%96%B9%E6%B3%95/</link><pubDate>Fri, 02 Jul 2021 12:49:27 +0800</pubDate><guid>https://www.zling.site/post/CSharp%E4%B8%AD%E5%8F%91%E9%80%81HTTP%E8%AF%B7%E6%B1%82%E7%9A%84%E6%96%B9%E6%B3%95/</guid><description>发送 Get 请求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // HttpClient is intended to be instantiated once per application, rather than per-use. See Remarks. static readonly HttpClient client = new HttpClient(); static async Task Main() { // Call asynchronous network methods in a try/catch block to handle exceptions. try { HttpResponseMessage response = await client.GetAsync(&amp;#34;http://www.contoso.com/&amp;#34;); response.EnsureSuccessStatusCode(); string responseBody = await response.Content.ReadAsStringAsync(); // Above three lines can be replaced with new helper method below // string responseBody = await client.GetStringAsync(uri); Console.WriteLine(responseBody); } catch(HttpRequestException e) { Console.WriteLine(&amp;#34;\nException Caught!&amp;#34;); Console.WriteLine(&amp;#34;Message :{0} &amp;#34;,e.Message); } } 发送 Post 请求 1 2 3 4 5 6 7 8 9 10 11 using (var httpClient = new HttpClient { BaseAddress = new Uri(cqcPlatformUrl) }) { httpClient.DefaultRequestHeaders.Add(&amp;#34;Test&amp;#34;, &amp;#34;TestValue&amp;#34;);</description></item><item><title>CSharp调用非托管C++时使用回调函数遇到的问题</title><link>https://www.zling.site/post/CSharp%E8%B0%83%E7%94%A8%E9%9D%9E%E6%89%98%E7%AE%A1C++%E6%97%B6%E4%BD%BF%E7%94%A8%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 07 Jun 2021 16:36:57 +0800</pubDate><guid>https://www.zling.site/post/CSharp%E8%B0%83%E7%94%A8%E9%9D%9E%E6%89%98%E7%AE%A1C++%E6%97%B6%E4%BD%BF%E7%94%A8%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</guid><description>如果该回调函数会被定时调用时，C#代码需要将回调函数对应的委托实例化成一个静态变量后使用，以避免 GC 将委托释放导致的异常问题。 参考：https://stackoverflow.com/questions/61985465/passing-c-sharp-callback-metho</description></item><item><title>CSharp中用线程安全的方式引发事件</title><link>https://www.zling.site/post/CSharp%E4%B8%AD%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E5%BC%95%E5%8F%91%E4%BA%8B%E4%BB%B6/</link><pubDate>Sat, 29 May 2021 23:47:02 +0800</pubDate><guid>https://www.zling.site/post/CSharp%E4%B8%AD%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E5%BC%95%E5%8F%91%E4%BA%8B%E4%BB%B6/</guid><description>在不考虑线程安全的情况下常常会写如下引发事件的代码: 1 2 3 4 5 6 7 // 版本1 public event EventHandle&amp;lt;EventArgs&amp;gt; Something; protected virtual void OnSomething(EventArgs e) { if(Something != null) Something(this, e); } 以上代码在单线程环境下能够正常运行，但是在多线程环境下就有可能导致问题。虽然对 Something 做了空引用的判断，但是在调用 Something 前有可能被另一个线程从委托链中移除委托，使得 Something 为空，导致空引用调</description></item><item><title>CSharp中的XML序列化</title><link>https://www.zling.site/post/CSharp%E4%B8%AD%E7%9A%84XML%E5%BA%8F%E5%88%97%E5%8C%96/</link><pubDate>Sat, 24 Apr 2021 22:04:09 +0800</pubDate><guid>https://www.zling.site/post/CSharp%E4%B8%AD%E7%9A%84XML%E5%BA%8F%E5%88%97%E5%8C%96/</guid><description>可 XML 序列化的内容 公有类的公有可读写属性和字段 接口 ICollection 或 IEnumerable 的实现类 XmlElement 对象 XmlNode 对象 DataSet 对象 XML 使用的 Attribute 通常 Xml 元素的名称由类名或成员名称，但是也可以通过 Attribute 去控制。 XmlArrayAttribute 和 XmlArrayItemAttribute XmlArrayAttribute 和 XmlArrayItemAttribute 用于控制数组的序列化。 XmlArrayAttribute 可以指定数组序列化时的 Xml元素名称。 1 2 3 4 public class Group { [XmlArray(&amp;#34;TeamMembers&amp;#34;)] public Employee[] Employees; } 1 2 3 4 5 6 7 &amp;lt;Group&amp;gt; &amp;lt;TeamMembers&amp;gt; &amp;lt;!-- 如果没有指定</description></item><item><title>CSharp的Environment类</title><link>https://www.zling.site/post/CSharp%E7%9A%84Environment%E7%B1%BB/</link><pubDate>Wed, 07 Apr 2021 18:39:41 +0800</pubDate><guid>https://www.zling.site/post/CSharp%E7%9A%84Environment%E7%B1%BB/</guid><description>1 var ev = Environment.GetEnvironmentVariable(&amp;#34;ev&amp;#34;);</description></item><item><title>CSharp中的压缩和解压</title><link>https://www.zling.site/post/CSharp%E4%B8%AD%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B/</link><pubDate>Mon, 05 Apr 2021 17:28:17 +0800</pubDate><guid>https://www.zling.site/post/CSharp%E4%B8%AD%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B/</guid><description>压缩和解压相关类 在 System.IO.Compression 中包含了有关压缩和解压的类： ZipFile ZipArchive ZipArchiveEntry DeflateStream GZipStream 文件的压缩和解压 流的压缩和解压</description></item></channel></rss>